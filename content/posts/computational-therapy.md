---
draft: true
tags:
- therapy
- cs
---

# Computational Therapy

> When learning, I have a tendency to try and apply abstract concepts to all sorts of different things - I have to adopt the language of the ideas and test it out in different (occasionally bizarre) realms. It seems that if I don't 'get' something at a very intuitive and general level, I set my confidence levels quite low. This is at least true for procedural memories, although I always seem to have a good capacity for episodic recall. 
> When it come to therapy, I found myself leaning on my episodic recall to 'pass the test', as it were. I wasn't *really* understanding procedural aspects with any flexibility or applicability - which is literally the point of therapies like CBT.
> I think this particular aspect of my cognitive profile indicates why I gravitate toward philosophy - I'm inclined to treat all ideas and concepts as scale-free[0]. The world of code is no exception:
> Below I use an analogy from Object-Oriented programming to discuss the trade-offs of this 'generalisability' approach to understanding. Going forward, I provide an example of how this concept can be applied therapeutically, in regard to reducing the complexity of our "shoulds and oughts". I provide reasons and methods for doing so, drawing from advice intended for programmers writing programs.
> [0] more on that particular idea will come in later posts.


What seems to be in common among almost every forum where advice can upvoted is that the absolute worst advice reaches the top, and hard-earned and plain advice sits placidly in the middle. A self-reinforcing culture of 'rationally-acquired best advice' tends to emerge. Another thing in common are the psychological traits they encourage - perfectionism, all-or-nothing thinking, and massively warped expectations which encourage imposter syndrome.

Getting good is inherently KISS, and the easiest thing in the world to procrastinate over. Expose yourself to external pressures and failure and imperfect results. Like exercise, you'll eventually find an ambivalent equilibrium of bad feeling leading to eventual reward, and your habits will keep you going. You don't need a rational justification for everything. Laziness and arbitrary preferences keep your stack of promises and 'shoulds' small and manageable. 

If you like, think of 'shoulds' or 'oughts' as objects. They necessarily communicate with one another, because of all the implications they have for each other in terms of available time; mental energy efficiency; precluding or depending on one another; useful things like two-birds-with-one-stone effects - etc etc. They encapsulate state and have all of it's problems. When a new message (piece of information) is propogated throughout the system, non-determinism and runaway complexity will cause gigantic lockups, particularly when paired with a requirement for a high degree of certainty about the state of the system at any one time.

Design your 'oughts' like a functional system - 
